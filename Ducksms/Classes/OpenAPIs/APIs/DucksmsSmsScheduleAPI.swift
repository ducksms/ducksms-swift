//
// DucksmsSmsScheduleAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

extension DucksmsAPI {


open class DucksmsSmsScheduleAPI {
    /**
     Cancel Sms Schedule
     
     - parameter id: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func cancelSmsSchedule(id: String, apiResponseQueue: DispatchQueue = DucksmsAPI.apiResponseQueue, completion: @escaping ((_ data: CancelSmsSchedule?,_ error: Error?) -> Void)) {
        cancelSmsScheduleWithRequestBuilder(id: id).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Cancel Sms Schedule
     - DELETE /api/v1/sms/scheduled/{id}
     - Cancel existing sms schedule
     - BASIC:
       - type: http
       - name: BearerToken
     - parameter id: (path)  
     - returns: RequestBuilder<CancelSmsSchedule> 
     */
    open class func cancelSmsScheduleWithRequestBuilder(id: String) -> RequestBuilder<CancelSmsSchedule> {
        var path = "/api/v1/sms/scheduled/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let URLString = DucksmsAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<CancelSmsSchedule>.Type = DucksmsAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     * enum for parameter filterType
     */
    public enum FilterType_listSmsSchedule: String, CaseIterable {
        case quick = "quick"
        case bulk = "bulk"
    }

    /**
     * enum for parameter filterMessageType
     */
    public enum FilterMessageType_listSmsSchedule: String, CaseIterable {
        case ascii = "ascii"
        case unicode = "unicode"
    }

    /**
     * enum for parameter filterStatus
     */
    public enum FilterStatus_listSmsSchedule: String, CaseIterable {
        case pending = "pending"
        case processing = "processing"
        case completed = "completed"
        case failed = "failed"
        case cancelled = "cancelled"
    }

    /**
     List Sms Schedule
     
     - parameter page: (query) Page number (optional)
     - parameter filterSenderName: (query) Filter by sender id name (optional)
     - parameter filterType: (query) Filter by sms type (optional)
     - parameter filterMessageType: (query) Filter by sms message type (optional)
     - parameter filterStatus: (query) Filter by sms status (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func listSmsSchedule(page: Int? = nil, filterSenderName: String? = nil, filterType: FilterType_listSmsSchedule? = nil, filterMessageType: FilterMessageType_listSmsSchedule? = nil, filterStatus: FilterStatus_listSmsSchedule? = nil, apiResponseQueue: DispatchQueue = DucksmsAPI.apiResponseQueue, completion: @escaping ((_ data: ListSmsSchedule?,_ error: Error?) -> Void)) {
        listSmsScheduleWithRequestBuilder(page: page, filterSenderName: filterSenderName, filterType: filterType, filterMessageType: filterMessageType, filterStatus: filterStatus).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List Sms Schedule
     - GET /api/v1/sms/scheduled
     - List all the sms schedule
     - BASIC:
       - type: http
       - name: BearerToken
     - responseHeaders: [X-Pagination-Count(Int), X-Pagination-Page(Int), X-Pagination-Limit(Int)]
     - parameter page: (query) Page number (optional)
     - parameter filterSenderName: (query) Filter by sender id name (optional)
     - parameter filterType: (query) Filter by sms type (optional)
     - parameter filterMessageType: (query) Filter by sms message type (optional)
     - parameter filterStatus: (query) Filter by sms status (optional)
     - returns: RequestBuilder<ListSmsSchedule> 
     */
    open class func listSmsScheduleWithRequestBuilder(page: Int? = nil, filterSenderName: String? = nil, filterType: FilterType_listSmsSchedule? = nil, filterMessageType: FilterMessageType_listSmsSchedule? = nil, filterStatus: FilterStatus_listSmsSchedule? = nil) -> RequestBuilder<ListSmsSchedule> {
        let path = "/api/v1/sms/scheduled"
        let URLString = DucksmsAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": page?.encodeToJSON(), 
            "filter[sender_name]": filterSenderName?.encodeToJSON(), 
            "filter[type]": filterType?.encodeToJSON(), 
            "filter[message_type]": filterMessageType?.encodeToJSON(), 
            "filter[status]": filterStatus?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<ListSmsSchedule>.Type = DucksmsAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

}
}
